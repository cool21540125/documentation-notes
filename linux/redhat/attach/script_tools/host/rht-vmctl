#!/bin/bash
#
# Copyright 2014 Red Hat, Inc.
#
# NAME
#     rht-vmctl - wrapper for RHCE lab grading scripts
#
# SYNOPSIS
#     rht-vmctl -h|--help
#     rht-vmctl [-q|--quiet] VMCMD VMNAME
#
#     where VMCMD is one of the following:
#       reset     - poweroff, recreate/restore overlay, start
#       view      - runs virt-viewer on VMNAME
#       start     - if stopped, start VMNAME (obtain and overlay image if
#                   not there)
#       stop      - if running, stop VMNAME
#       poweroff  - if running, poweroff VMNAME
#       save      - stop, backup overlay, start (this is typically used as
#                   a checkpoint for sequential labs that build on each other)
#       restore   - stop, restore overlay, start (use save)
#       get       - download image, create overlay
#       fullreset - poweroff, redownload image, recreate overlay, start
#                   (this subcommand is used when a bad save has been made)
#       status    - show status of VMNAME on this system
#
# DESCRIPTION
#     This tool is used to manage the virtual machines on this
#     local hypervisor layer system.
#
#     File naming conventions:
#        $RHT_COURSE-$VMNAME.xml - libvirt VM XML definition
#        $RHT_COURSE-$VMNAME-vdZ.qcow2 - master image vdZ
#        $RHT_COURSE-$VMNAME-vdZ.ovl - overlay of vdZ
#        $RHT_COURSE-$VMNAME-vdZ.ovl-$SAVE - backup of overlay
#
# CHANGELOG
#   * Thu Jul 10 2014 Robert Locke <rlocke@redhat.com>
#   - shift f0 infrastructure VMs from RHT_VMS to RHT_VM0
#   * Wed Jul  2 2014 Robert Locke <rlocke@redhat.com>
#   - add support for save/restore/fullreset of classroom
#   - add remove for classroom
#   - make remove prompt for confirmation (in case anyone finds it)
#   * Tue Jun 24 2014 Robert Locke <rlocke@redhat.com>
#   - add hidden "remove" verb
#   * Thu Jun 19 2014 Robert Locke <rlocke@redhat.com>
#   - add status verb
#   * Thu Jun 12 2014 Robert Locke <rlocke@redhat.com>
#   - virsh start generate error messages about missing virt/kvm
#   * Wed Jun 11 2014 Robert Locke <rlocke@redhat.com>
#   - add hidden "viewstart" verb (used by desktop icons)
#   * Tue May 20 2014 George Hacker <ghacker@redhat.com>
#   - cleaned up output for user experience
#   * Sun Apr 20 2014 Rob Locke <rlocke@redhat.com>
#   - original code

PATH=/usr/bin:/bin:/usr/sbin:/sbin

# Some variables
CONTENTSERVER=content.example.com
VMBLKPATH=/var/lib/libvirt/images

# Source some variables that we need - should provide:
# RHT_VENUE=ilt
# RHT_ENROLLMENT=X
# RHT_COURSE=rh124
# RHT_ROLE=foundation
# RHT_VMTREE=rhel7.0/x86_64
# RHT_VMS="desktop server"
# RHT_VM0="classroom"
source /etc/rht
# Validate
if [[ -z "${RHT_ENROLLMENT}" || -z "${RHT_COURSE}" || -z "${RHT_VMS}" || -z "${RHT_VMTREE}" ]]; then
  echo "Error: missing a needed variable from /etc/rht"
  echo "RHT_ENROLLMENT = '${RHT_ENROLLMENT}'"
  echo "RHT_COURSE     = '${RHT_COURSE}'"
  echo "RHT_VMTREE     = '${RHT_VMTREE}'"
  echo "RHT_VMS        = '${RHT_VMS}'"
  exit 2
fi

# Source library of functions
source /usr/local/lib/rhttool.shlib
# trap on_exit EXIT

# Additional functions for this shell script
function print_usage {
cat << EOF

This utility manages the Red Hat Training supplied VMs on the local
hypervisor.

Usage: rht-vmctl [-q|--quiet] VMCMD VMNAME
       rht-vmctl -h|--help

  where VMCMD is one of:
    reset      - poweroff, return to saved or original state, start VMNAME
    view       - launches console viewer of VMNAME
    start      - obtain and start up VMNAME
    stop       - stop a running VMNAME
    poweroff   - if running, force stop VMNAME
    save       - stop, backup image, start VMNAME
    restore    - poweroff, restore image, start VMNAME
    fullreset  - poweroff, reobtain from server, start VMNAME (bad save/image)
    get        - if not here, obtain VMNAME from server
    status     - display libvirt status of VMNAME

EOF
}

function get_latest {
  latest=$( ls -1 $* 2>/dev/null | tail -n1 )
  echo ${latest}
}

function rht_get_vm {
  VMNAME=$1
  if is_running $VMNAME ; then
    debug "Not getting. $VMNAME is already running."
    return
  fi
  # If needed, get (and fix) libvirt XML definition file
  if [[ ! -f $VMBLKPATH/$RHT_COURSE-$VMNAME.xml ]]; then
    if [[ "${RHT_VM0}" == *${VMNAME}* ]] ; then
      echo "Error: missing libvirt XML definition - $VMBLKPATH/$RHT_COURSE-$VMNAME.xml"
      exit 12
    fi
    echo "Downloading virtual machine definition file for ${VMNAME}."
    curl -# -o $VMBLKPATH/$RHT_COURSE-$VMNAME.xml \
	 http://${CONTENTSERVER}/$RHT_VMTREE/vms/$RHT_COURSE-$VMNAME.xml
  fi
  # Need to convert MAC address to match RHT_ENROLLMENT
  # Shift disk(s) to use overlay file(s)
  RHT_ENROLLMENT_HEX=$(printf %02X $RHT_ENROLLMENT)
  sed -i -e "s/RHT_ENROLLMENT_HEX/${RHT_ENROLLMENT_HEX}/" \
	 -e "s/\.qcow2/.ovl/" $VMBLKPATH/$RHT_COURSE-$VMNAME.xml
  # Loop through disk definitions
  for VDISK in $( grep -o $RHT_COURSE-$VMNAME-vd. $VMBLKPATH/$RHT_COURSE-$VMNAME.xml 2>/dev/null ) ; do
    # If needed, retrieve qcow2 file
    if [[ ! -f $VMBLKPATH/$VDISK.qcow2 ]]; then
      if [[ "${RHT_VM0}" == *${VMNAME}* ]] ; then
	echo "Error: missing master QCOW2 image - $VMBLKPATH/$VDISK.qcow2"
	exit 12
      fi
      # Since we are retrieving, make sure the overlays are also gone
      rm -f $VMBLKPATH/$VDISK.ovl*
      echo "Downloading virtual machine disk image ${VDISK}"
      curl -# -o $VMBLKPATH/$VDISK.qcow2 \
           http://${CONTENTSERVER}/$RHT_VMTREE/vms/$VDISK.qcow2
    fi
    # If needed, re-create or restore overlay file
    if [[ ! -f $VMBLKPATH/$VDISK.ovl ]]; then
      OVLRESTORE=$(get_latest $VMBLKPATH/$VDISK.ovl-*)
      # If there is no save, create overlay from master
      if [[ -z "${OVLRESTORE}" ]]; then
        echo "Creating virtual machine disk overlay for ${VDISK}"
        qemu-img create -q -f qcow2 -b $VMBLKPATH/$VDISK.qcow2 $VMBLKPATH/$VDISK.ovl
      # else restore latest save
      else
        echo "Restoring from ${OVLRESTORE}"
        cp $OVLRESTORE $VMBLKPATH/$VDISK.ovl
      fi
    fi
  done
}

function rht_start_vm {
  local VMNAME=$1
  if is_running $VMNAME ; then
    echo  "Error: $VMNAME not started (is already running)"
    return 11
  fi
  rht_get_vm $VMNAME
  # if not libvirt defined ; then define it
  if ! is_defined $VMNAME ; then
    debug "Defining ${VMNAME} from its xml file."
    virsh define $VMBLKPATH/$RHT_COURSE-$VMNAME.xml &> /dev/null
  fi
  echo "Starting ${VMNAME}."
  virsh -q start ${VMNAME} > /dev/null
  # If we are on foundation0, set autostart if infrastructure VMs
  if [[ "${RHT_VM0}" == *${VMNAME}* ]]; then
    debug "Configuring ${VMNAME} to autostart."
    virsh autostart $VMNAME &> /dev/null
  fi
}

function rht_stop_vm {
  VMNAME=$1
  echo -n "Stopping ${VMNAME}."
  # Cap how long we are going to wait
  i=20
  while is_running $VMNAME && [[ $i -gt 0 ]]; do
    virsh shutdown $VMNAME &> /dev/null
    sleep 5
    let i=i-1
    echo -n '.'
  done
  echo
  if is_running $VMNAME ; then
    rht_poweroff_vm $VMNAME
  fi
  if is_running $VMNAME ; then
    echo "Error: unable to stop $VMNAME."
    echo 'Try manually shutting it down then try again.'
    exit 5
  fi
}

function rht_poweroff_vm {
  VMNAME=$1
  echo -n "Powering off ${VMNAME}."
  # Cap how long we are going to wait
  i=5
  while is_running $VMNAME && [[ $i -gt 0 ]]; do
    virsh destroy $VMNAME &> /dev/null
    sleep 5
    let i=i-1
    echo -n '.'
  done
  echo
  if is_running $VMNAME ; then
    echo "Error: unable to poweroff $VMNAME."
    echo 'Try manually stopping it then try again.'
    exit 5
  fi
}

function rht_reset_vm {
  VMNAME=$1
  if confirm_yn "Are you sure you want to reset ${VMNAME}?"; then
    echo "Resetting ${VMNAME}."
    rht_poweroff_vm $VMNAME
    rht_drop_blk $VMNAME overlay
    rht_start_vm $VMNAME
  fi
}

function rht_fullreset_vm {
  VMNAME=$1
  if confirm_yn "Are you sure you want to full reset ${VMNAME}?"; then
    echo "Full resetting ${VMNAME}."
    rht_poweroff_vm $VMNAME
    rht_drop_blk $VMNAME master
    rht_start_vm $VMNAME
  fi
}

function rht_remove_vm {
  VMNAME=$1
  if confirm_yn "Are you sure you want to remove ${VMNAME}?"; then
    echo "Removing ${VMNAME}."
    rht_poweroff_vm $VMNAME
    rht_drop_blk $VMNAME master
  fi
}

function rht_save_vm {
  VMNAME=$1
  if ! is_defined $VMNAME ; then
    echo "Error: ${VMNAME} is not defined - nothing to save."
  else
    echo "Saving ${VMNAME} disk image."
    rht_stop_vm $VMNAME
    # Loop through disk definitions
    SAVEDATE=$(date +%Y%m%d%H%M)
    for VDISK in $( grep -o $RHT_COURSE-$VMNAME-vd. $VMBLKPATH/$RHT_COURSE-$VMNAME.xml 2>/dev/null ) ; do
      cp $VMBLKPATH/$VDISK.ovl $VMBLKPATH/$VDISK.ovl-$SAVEDATE
    done
    rht_start_vm $VMNAME
  fi
}

function rht_restore_vm {
  VMNAME=$1
  if ! is_defined $VMNAME ; then
    echo "Error: $VMNAME is not defined - nothing to restore."
  else
    echo "Restoring disk image for ${VMNAME}."
    # Confirm there is a save for each disk and abort if not
    for VDISK in $( grep -o $RHT_COURSE-$VMNAME-vd. $VMBLKPATH/$RHT_COURSE-$VMNAME.xml 2>/dev/null ) ; do
      if [[ -z "$(get_latest $VMBLKPATH/$VDISK.ovl-*)" ]]; then
	echo "Error: ${VMNAME} missing backup for ${VDISK}.ovl."
	return
      fi
    done
    rht_poweroff_vm $VMNAME
    # Loop through disk definitions and restore
    for VDISK in $( grep -o $RHT_COURSE-$VMNAME-vd. $VMBLKPATH/$RHT_COURSE-$VMNAME.xml 2>/dev/null ) ; do
      cp $(get_latest $VMBLKPATH/$VDISK.ovl-*) $VMBLKPATH/$VDISK.ovl
    done
    rht_start_vm $VMNAME
  fi
}

function rht_view_vm {
  VMNAME=$1
  if is_running ${VMNAME} ; then
    virt-viewer ${VMNAME} &> /dev/null &
  else
    echo "Error: unable to view ${VMNAME} - not currently running."
  fi
}

function rht_viewstart_vm {
  VMNAME=$1
  if ! is_running ${VMNAME} ; then
    rht_start_vm ${VMNAME}
  fi
  rht_view_vm ${VMNAME}
}

function rht_status_vm {
  VMNAME=$1
  if is_running ${VMNAME} ; then
    echo -e "${VMNAME} \\033[1;32mRUNNING\\033[0;39m"
  else
    echo -e "${VMNAME} \\033[1;31mMISSING\\033[0;39m"
  fi
}

function rht_drop_blk {
  VMNAME=$1
  VMBLK=$2
  # Loop through disk definitions
  for VDISK in $( grep -o $RHT_COURSE-$VMNAME-vd. $VMBLKPATH/$RHT_COURSE-$VMNAME.xml 2>/dev/null ) ; do
    debug "Dropping $VDISK-$VMBLK."
    if [ "$VMBLK" = "saves" ] ; then
      rm -f $VMBLKPATH/$VDISK.ovl-*
    fi
    if [ "$VMBLK" = "overlay" ] ; then
      rm -f $VMBLKPATH/$VDISK.ovl
    fi
    if [ "$VMBLK" = "master" ] ; then
      rm -f $VMBLKPATH/$VDISK.ovl-*
      rm -f $VMBLKPATH/$VDISK.ovl
      if [[ "${RHT_VM0}" != *${VMNAME}* ]] ; then
        rm -f $VMBLKPATH/$VDISK.qcow2
      fi
    fi
  done
  # If removing master, also undefine and remove xml file
  if [ "$VMBLK" = "master" ] ; then
    debug "Undefining ${VMNAME}."
    virsh undefine $VMNAME &> /dev/null
    if [[ "${RHT_VM0}" != *${VMNAME}* ]] ; then
      rm -f $VMBLKPATH/$RHT_COURSE-$VMNAME.xml
    fi
  fi
}

# Main area
# If I need root privileges to run, then use sudo to call myself
if [[ "$EUID" -gt "0" ]] ; then
  debug 'Using sudo to become root.'
  sudo $0 "$@"
  exit
fi
# Process command line
VMCMD=""
VMNAME=""
# Parse input
until [ -z "$1" ] ; do
  case $1 in
    start|stop|poweroff|reset|fullreset|save|restore|get|view|viewstart|status|remove)
      VMCMD=$1
      shift
      VMNAME=$1
      ;;
    -h|--help)
      print_usage
      exit 0
      ;;
    -q|--quiet)
      QUIET=yes		# confirm_yn() checks for this variable
      ;;
    -d|--debug)
      DEBUG=true	# debug() checks for this variable
      ;;
    *)
      echo "Error: bad option, $1"
      print_usage
      exit 1
      ;;
  esac
  shift
done
# Validation
if [[ -z "$VMCMD" || -z "$VMNAME" ]]; then
  echo "Error: missing subcommand or VMNAME."
  print_usage
  exit 1
fi
# Validate VMNAME
match=0
my_vms=${VMNAME}
if [[ "${VMNAME}" == "all" ]]; then
  [[ "${RHT_ENROLLMENT}" -eq 0 && -n "${RHT_VM0}" ]] && my_vms="${RHT_VM0} ${RHT_VMS}" || my_vms="${RHT_VMS}"
  match=1
else
  for i in $RHT_VMS $RHT_VM0 ; do
    [[ "$i" == "$VMNAME" ]] && match=1
  done
fi
if [[ $match -eq 0 ]]; then
  echo "Error: unrecognized VMNAME specified, ${VMNAME}."
  print_usage
  exit 1
fi

for i in $my_vms ; do
  # Branch based on request
  debug "We will ${VMCMD} ${i}."
  rht_${VMCMD}_vm ${i}
done
