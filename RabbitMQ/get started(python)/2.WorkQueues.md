# 2. Work Queues

- 2019/07/05
- [Work Queues](https://www.rabbitmq.com/tutorials/tutorial-two-python.html)

本文要實作下面的架構

![Two Queues](../../img/python-two.png)

- 第 1 篇實作了將訊息發送到 `named queue`, 而本篇要實作 `工作佇列(Work Queues)`, 將耗時的工作分配給多個 workers 來處理
- `Work Queues (Task Queues)` 最初被設計出來, 就是要來處理一些 資源密集(耗資源) 的任務, 交由後端 Server 處理
- Work Queues 的設計對於 Web App 十分有幫助. (複雜工作無法在短時間內的 HTTP Request & HTTP Response 之間完成), 避免前端用戶在那邊傻傻等待

## 1. Sending

```python
### new_task.py
import pika
conn = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = conn.channel()
channel.queue_declare(queue='hello')

import sys
message = ' '.join(sys.argv[1:]) or 'Hello World!'

# 回傳用戶端傳送過來的 第 1 個參數 or Hello World!
channel.basic_publish(exchange='',
                      routing_key='hello',
                      body=message)

print(" [x] Sent %r" % message)
conn.close()

```

```bash
### new_task.py 開始瘋狂的新增任務吧~
python new_task.py 1
python new_task.py 2
python new_task.py 3
python new_task.py 4
python new_task.py 5
python new_task.py 6
python new_task.py 7
python new_task.py 8

```


## 2. Receiving

```python
### worker.py
import pika
conn = pika.BlockingConnection(pika.ConnectionParameters('localhost'))
channel = conn.channel()
channel.queue_declare(queue='hello')

import time
def complex_callback(ch, method, properties, body):
    print(" [x] Waited %r" % body)
    try:
        t = int(body.decode('utf-8'))
    except:
        t = 2
    time.sleep(t)
    # time.sleep(body.count(b'.'))
    print(" [x] Done")

channel.basic_consume(queue='hello',
                      auto_ack=True,
                      on_message_callback=complex_callback)
# auto_ack 預設為 False, 若設為 True, 則為 automatic acknowledgement mode

print(' [*] Waiting for messages. To exit press CTRL+C')

channel.start_consuming()

```

```bash
### 要開兩個以上的 Terminal 來當作 Consumer
python worker.py
```


### Consumer Acknowledgements

根據上述的做法, 可能 Consumer 拿到工作, 做到一半就掛了... 從此沒人會知道該工作進度如何..., 這部分可 [message ack(nowledgements)](https://www.rabbitmq.com/confirms.html)

- ack 機制, 是藉由 consumer 告知 RabbitMQ Server 特定的 message 已經收到了, 已經處理了, ..., 好讓 RabbitMQ 可以把該 message 刪除. -> 所以如果 consumer 掛了(channel 被關閉, connection 中斷, TCP connection 遺失), RabbitMQ 會知道哪個 message 沒有被妥善處理, 所以它會 `re-queue` 這則 message.



### Round-robin dispatching

- `Task Queue` 其中一個好處, 可以做 Load Balance.


## Terminal

```bash
###
$# rabbitmqctl list_queues name messages_ready messages_unacknowledged

```