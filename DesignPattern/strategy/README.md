# Strategy Pattern

![Strategy](/img/DesignPattern/Strategy.png)

## 概念摘要

- 又稱為 Policy Pattern, 允許在 Run Time 期間選擇一種演算法 的一種行為設計模式
    - Run Time 期間, 依據所收到的參數來判斷要實行哪種演算方式
    - 讓策略的演算過程與 Client 獨立開來
- 相較於簡單工廠模式(直接回傳類別實例), 它直接在方法內部去實作策略實例的建構, 並且執行實際策略的方法
- 如果接收到的需求像是, 這東西要能完成 OO 功能, 但是 OO 還不是很明確, 而且將來可把 OO 替換成 XX, YY, ... 等等的功能. 若這樣就可考慮 策略模式.
    - 經典的範例就像是:
        - 排序: 你永遠都不知道要 大到小, 按照筆畫, 按照注音, ...
        - 驗證: 18歲以上才可以幹嘛幹嘛, 18歲以上且持有護照才可幹嘛幹嘛, ...
        - 產出: 依照輸入, 處理完後輸出 csv, pdf, txt, ...
        - 儲存: 存到 DB, 存成檔案, 作 API Request, ...
        - 角色動作: 從 A 到 B, 要用走的, 用跑的, 用游的, 將來也可能有瞬間移動的需求也說不定
- 若將來有新的實體策略的需求時, 只需要增加策略類別 & 改寫 Context

# CS 實作

`冒險者` 打怪, 打怪時可用 `普通攻擊`, `技能攻擊`, `魔法攻擊`

如果一開始, 單純的想說

```cs
class 冒險者
{
    public void 普通攻擊() { /* ... */ }
    public void 技能攻擊() { /* ... */ }
    public void 魔法攻擊() { /* ... */ }
}

// 下面是主程式
冒險者 tony = new 冒險者();
tony.普通攻擊();    // 用拳頭
tony.技能攻擊();     // 拿刀砍
tony.魔法攻擊();     // 超強蒼蠅拍電擊
```

那將來會出現說, 如果冒險者有分為: 人類冒險者, 精靈冒險者 ...

而且每個冒險者, 他們攻擊的方式都不一樣, 那將來冒險者勢必得分成:

```cs
abstract class 冒險者 {
    abstract void 普通攻擊();
    abstract void 技能攻擊();
    abstract void 魔法攻擊();
}

class 人類 : 冒險者 {
    void 普通攻擊();    // 用拳頭
    void 技能攻擊();     // 拿刀砍
    void 魔法攻擊();     // 超強蒼蠅拍電擊
}

class 精靈 : 冒險者 {
    void 普通攻擊();    // 用腳踹
    void 技能攻擊();     // 射弓箭
    void 魔法攻擊();     // 放火球
}
```

恩~ 看起來會有幾個缺點

1. 如果將來每增加一個種族, ex: 矮人冒險者, 那就得在來一包 `class Draft : 冒險者 { ... }`, 等於直接宣判了新增的種族都會 技能攻擊 以及 魔法攻擊...@@!? 萬一它們不會哩...??
2. 如果要來個 祭司冒險者, 但是他只會 Cure, Armor, SpeedAttack 等方法, 那 冒險者 就又得增加新的虛方法來因應變化, 從而導致 人類, 精靈 都得在實作這些根本不存在的方法

所以不如把這種 `會 技能攻擊`, `會 魔法攻擊` 的人物, 提出到介面

```cs
interface I普通攻擊 {
    void 普通攻擊();
}

interface I技能攻擊 {
    void 技能攻擊();
}

interface I魔法攻擊 {
    void 魔法攻擊();
}
```

然後再讓各種腳色來實作它們

```cs
abstract class 冒險者 {
    abstract void 普通攻擊();
    abstract void 技能攻擊();
    abstract void 魔法攻擊();
}

class 人類 : 冒險者, I普通攻擊, I技能攻擊, I魔法攻擊 {
    public void 普通攻擊() { /* ...;*/ }    // 用拳頭
    public void 技能攻擊() { /* ...;*/ }    // 拿刀砍
    public void 魔法攻擊() { /* ...;*/ }    // 超強蒼蠅拍電擊
}

class 精靈 : 冒險者 {
    public void 普通攻擊() { /* ...;*/ }    // 用腳踹
    public void 技能攻擊() { /* ...;*/ }    // 射弓箭
    public void 魔法攻擊() { /* ...;*/ }    // 放火球
}
```

這樣看似舒服多了? 將來如果多一種攻擊方式, 只需要再實作那個介面即可~

阿如果萬一有個全能種族, 他會 87 種攻擊方式, 那就要...

```cs
// 宣告 87 種攻擊方式的介面好像是必要的齁!!?? 在此省略

class PowerfulRace : I普通攻擊, I技能攻擊, I空中轉體180度攻擊, I毒氣攻擊, ......
{

}
```